(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        ((exponentiation? exp)
         (make-product (exponent exp)
                       (make-exponentiation (base exp)
                                             (1- (exponent exp)))
                       (deriv (base exp) var)))
        (else
         (error "unknown expression type -- DERIV" exp))))

(define (variable? x) (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (filter predicate sequence)
  (cond ((null? sequence) '())
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))

(define (make-expression op args)
  (define (maker op args)
    (if (null? (cdr args))
        args
      (append (list (car args) op)
              (maker op (cdr args)))))
  (let ((res (maker op args)))
    (if (= 1 (length res))
        (car res)
        res)))

(define (make-sum . args)
  (let ((s (accumulate + 0 (filter number? args)))
        (vars (filter (lambda (a) (not (number? a))) args)))
    (if (and (> (length vars) 0) (= s 0))
        (make-expression '+ vars)
        (make-expression '+ (append vars (list s))))))
(define (sum? x)
  (and (list? x) (memq '+ x)))
(define (addend s)
  (define (split s)
    (if (eq? (car s) '+)
        '()
        (cons (car s) (split (cdr s)))))
  (let ((res (split s)))
    (if (= 1 (length res))
        (car res)
        res)))
(define (augend s)
  (let ((res (cdr (memq '+ s))))
    (if (> (length res) 1)
        res
        (car res))))

(define (make-product . args)
  (let ((p (accumulate * 1 (filter number? args)))
        (vars (filter (lambda (a) (not (number? a))) args)))
    (cond ((= 0 p) p)
          ((and (> (length vars) 0) (= 1 p))
           (make-expression '* vars))
          (else
           (make-expression '* (append vars (list p)))))))
(define (product? x)
  (and (pair? x) (pair? (cdr x)) (eq? (cadr x) '*)))
(define (multiplier p) (car p))
(define (multiplicand p)
  (if (> (length p) 3)
      (cddr p)
      (caddr p)))

(define (make-exponentiation b e)
  (cond ((=number? e 1) b)
        ((=number? e 0) 1)
        ((and (number? b) (number? e)) (expt b e))
        (else (list b '** e))))
(define (exponentiation? x)
  (and (pair? x) (pair? (cdr x)) (eq? (cadr x) '**)))
(define (base e) (car e))
(define (exponent e) (caddr e))


; tests
(deriv '(x + 3) 'x)
(deriv '(x * y) 'x)
(deriv '(x ** 2) 'x)
(deriv '(x + (3 * (x + (y + 2)))) 'x)
(deriv '(x + 3 * (x + y + 2)) 'x)
(deriv '(3 * (x + y + 2) + x) 'x)
(deriv '(3 * x + 3 * y + 6 + x) 'x)
(deriv '(3 * x * y) 'x)


